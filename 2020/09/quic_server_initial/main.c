#include <openssl/evp.h>
#include <openssl/kdf.h>
#include <stdio.h>
#include <string.h>

int
main()
{
	const uint8_t key[] = {
		0x14, 0x9d, 0x0b, 0x16, 0x62, 0xab, 0x87, 0x1f,
		0xbe, 0x63, 0xc4, 0x9b, 0x5e, 0x65, 0x5a, 0x5d,
	};

	const uint8_t iv[] = {
		0xba, 0xb2, 0xb1, 0x2a, 0x4c, 0x76, 0x01, 0x6a,
		0xce, 0x47, 0x85, 0x6d,
	};

	const uint8_t aad[] = {
		0xc1, 0xff, 0x00, 0x00, 0x1d, 0x00, 0x08, 0xf0,
		0x67, 0xa5, 0x50, 0x2a, 0x42, 0x62, 0xb5, 0x00,
		0x40, 0x74, 0x00, 0x01,
	};

	// the packet number is 0x0001;
	uint8_t nonce[sizeof(iv)];
	memcpy(nonce, iv, 11);
	nonce[11] = iv[11] ^ 0x01;

	const uint8_t pt[] = {
		0x0d, 0x00, 0x00, 0x00, 0x00, 0x18, 0x41, 0x0a,
		0x02, 0x00, 0x00, 0x56, 0x03, 0x03, 0xee, 0xfc,
		0xe7, 0xf7, 0xb3, 0x7b, 0xa1, 0xd1, 0x63, 0x2e,
		0x96, 0x67, 0x78, 0x25, 0xdd, 0xf7, 0x39, 0x88,
		0xcf, 0xc7, 0x98, 0x25, 0xdf, 0x56, 0x6d, 0xc5,
		0x43, 0x0b, 0x9a, 0x04, 0x5a, 0x12, 0x00, 0x13,
		0x01, 0x00, 0x00, 0x2e, 0x00, 0x33, 0x00, 0x24,
		0x00, 0x1d, 0x00, 0x20, 0x9d, 0x3c, 0x94, 0x0d,
		0x89, 0x69, 0x0b, 0x84, 0xd0, 0x8a, 0x60, 0x99,
		0x3c, 0x14, 0x4e, 0xca, 0x68, 0x4d, 0x10, 0x81,
		0x28, 0x7c, 0x83, 0x4d, 0x53, 0x11, 0xbc, 0xf3,
		0x2b, 0xb9, 0xda, 0x1a, 0x00, 0x2b, 0x00, 0x02,
		0x03, 0x04,
	};

	uint8_t ct[1024];
	int len, ct_len;

	EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();

	if (EVP_EncryptInit_ex(ctx, EVP_aes_128_gcm(), NULL, key, nonce) == 0) {
		return 1;
	}

	if (EVP_EncryptUpdate(ctx, NULL, &len, aad, sizeof(aad)) == 0) {
		return 1;
	}

	if (EVP_EncryptUpdate(ctx, ct, &ct_len, pt, sizeof(pt)) == 0) {
		return 1;
	}

	if (EVP_EncryptFinal_ex(ctx, ct + ct_len, &len) == 0) {
		return 1;
	}

	if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, 16, ct + ct_len) == 0) {
		return 1;
	}

	EVP_CIPHER_CTX_free(ctx);

	uint8_t decrypted[1024];
	int decrypted_len;
	ctx = EVP_CIPHER_CTX_new();

	if (EVP_DecryptInit_ex(ctx, EVP_aes_128_gcm(), NULL, key, nonce) == 0) {
		return 1;
	}
	if (EVP_DecryptUpdate(ctx, NULL, &len, aad, sizeof(aad)) == 0) {
		return 1;
	}
	if (EVP_DecryptUpdate(ctx, decrypted, &decrypted_len, ct, ct_len) == 0) {
		return 1;
	}
	if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, 16, ct + ct_len) == 0) {
		return 1;
	}
	if (EVP_DecryptFinal_ex(ctx, decrypted + decrypted_len, &len) == 0) {
		return 1;
	}

	EVP_CIPHER_CTX_free(ctx);
	return 0;
}
